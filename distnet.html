<!DOCTYPE html>
<meta charset="utf-8">

<title>Distance matrix graph display</title>

<!--INPUTDATA-->

<style>

#scatterpanel circle {
   fill: DarkGray;
   stroke: black;
   fill-opacity: .9;
}

#scatterpanel line {
   stroke: DarkBlue; 
   stroke-width: 1.5; 
}

#scatterpanel circle.selected {
   stroke: DarkRed;
   stroke-width: 2;
}

#scatterpanel line.selected {
   stroke: DarkRed;
}

</style>



</svg>

<table style="padding-top:30px">
   <tr>
      <td><svg id="scatterpanel" class="chart" width="600" height="600"></svg></td>
      <td valign="top" align="left" style="padding-left:20px" width="200"><p id="point_text"></p></td>
    </tr><tr>
       <td><svg id="color_bar" width="600px" height="25px"></svg></td>
       <td></td>
    </tr><tr>
       <td style="padding-bottom:30px"><div id="slider_threshold" style="width:600px"></div></td>
       <td></td>
    </tr><tr>
       <td style="padding-bottom:20px"><div id="slider_slope" style="width:600px"></div></td>
       <td style="padding-left:20px"><div id="bottomtextbox"></div></td>
    </tr>
</table>


<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<link rel="stylesheet" href="https://rawgit.com/MasterMaps/d3-slider/master/d3.slider.css"></link>
<script src="https://rawgit.com/MasterMaps/d3-slider/master/d3.slider.js"></script>


<script>

// Prepare the input data

var pointsdata = []
for( i = 0; i < inputdata.points2D.length; i++ ) 
   pointsdata.push( { 
      x: inputdata.points2D[i][0], 
      y: inputdata.points2D[i][1], 
      id: inputdata.tags[i],
      text: inputdata.info[i] } )

var distslist = []
for( i = 0; i < inputdata.distmat.length; i++ )
   for( j = i+1; j < inputdata.distmat.length; j++ )
      distslist.push( { p1: i, p2: j, dist: inputdata.distmat[i][j] })


// The minum alpha value, for which a line is still drawn
const alpha_threshold = .02

// The sigmoid function:
function sigmoid( x, threshold, slope ) {
   var midpoint = threshold + Math.log( 1/alpha_threshold - 1 ) / slope
   return 1 / ( 1 + Math.exp( -slope * ( x - midpoint ) ) )
}

// This function takes an object 'scales' with linear scales in slots 'x' and 'y',
// and changes them to get the desired x:y aspect ratio 'asp'.
function fix_aspect_ratio( scales, asp ) {
   var xfactor = ( scales.x.range()[1] - scales.x.range()[0] ) / 
      ( scales.x.domain()[1] - scales.x.domain()[0] )
   var yfactor = ( scales.y.range()[1] - scales.y.range()[0] ) / 
      ( scales.y.domain()[1] - scales.y.domain()[0] )
   var curasp = xfactor / yfactor  // current aspect ratio
   if( curasp > asp ) {  // x domain has to be expanded
      var cur_dom_length = ( scales.x.domain()[1] - scales.x.domain()[0] )
      var extension = cur_dom_length * ( curasp/asp - 1 ) / 2
      console.log( "extend x by", extension )
      scales.x.domain( [ scales.x.domain()[0] - extension, scales.x.domain()[1] + extension ] )      
   } else { // y domain has to be expanded
      var cur_dom_length = ( scales.y.domain()[1] - scales.y.domain()[0] )
      var extension = cur_dom_length * ( asp/curasp - 1 ) / 2
      console.log( "extend y by", extension )
      scales.y.domain( [ scales.y.domain()[0] - extension, scales.y.domain()[1] + extension ] )            
   }
   return( scales )
}

// Two convenience functions

function minmax( x ) {
   return [ d3.min(x), d3.max(x) ]
}

function square( x ) {
   return x * x
}

// Set the scales
var scales = {
   x: d3.scale.linear()
      .domain( minmax( pointsdata.map( function(a) { return a.x } ) ) )
      .range( [ 0, 600 ] ),
   y: d3.scale.linear()
      .domain( minmax( pointsdata.map( function(a) { return a.y } ) ) )
      .range( [ 0, 600 ] ) }
fix_aspect_ratio( scales, 1 )      
scales.x.clamp( true )
scales.y.clamp( true )


// The scale object for the color bar:
var color_bar_scale = d3.scale.linear()
   .domain( [ 0, d3.max( distslist.map( function(a) { return a.dist } ) ) ] )
   .range( [ 0, 600 ])
   .nice()


// The two sliders:

var slider_threshold = d3.slider()
   .axis( true )
   .max( color_bar_scale.domain()[1] )
   .on( "slide", update )
   .value( color_bar_scale.domain()[1] / 4 )
d3.select('#slider_threshold').call( slider_threshold )

var slider_slope = d3.slider()
   .max( slider_threshold.max() * 1.5 )
   .value( slider_threshold.max() * .5 )
   .on( "slide", update )
d3.select('#slider_slope').call( slider_slope )      



// The data array for the color bar:

var distvalgrid = []
var distvalgridstep = ( color_bar_scale.domain()[1] - color_bar_scale.domain()[0] ) / 100 
for( v = color_bar_scale.domain()[0]; v < color_bar_scale.domain()[1]; v += distvalgridstep ) {
  distvalgrid.push( v )
}


// A drag behavior for the points, to be added below  to each point:

var drag = d3.behavior.drag()
   .on( "drag", function( d, i ) {
       d.x = scales.x.invert( scales.x(d.x) + d3.event.dx )
       d.y = scales.y.invert( scales.y(d.y) + d3.event.dy )
       update() })


// The currently selected (highlighted) point

var selected_point = -1


// The update function

function update() {


   // lines:

   mysigmoid = function( x ) { return sigmoid( x, slider_threshold.value(), -slider_slope.value() ) } 

   var shortdistslist = distslist.filter( 
      function(a) { return mysigmoid( a.dist ) > alpha_threshold } )

   var selection = d3.select("#scatterpanel").selectAll("line")
      .data( distslist )
   selection.enter().insert("line")
   selection
      .attr( "x1", function(d) { return scales.x( pointsdata[d.p1].x ) } )
      .attr( "y1", function(d) { return scales.y( pointsdata[d.p1].y ) } )
      .attr( "x2", function(d) { return scales.x( pointsdata[d.p2].x ) } )
      .attr( "y2", function(d) { return scales.y( pointsdata[d.p2].y ) } )
      .style( "display", function(d) { return mysigmoid( d.dist ) > alpha_threshold ? null : "none" } )
      .style( "stroke-opacity", function(d) { return mysigmoid( d.dist ) } )
      .classed( "selected", function(d,i) { return d.p1 == selected_point | d.p2 == selected_point } )


   // points:

   selection = d3.select("#scatterpanel").selectAll("circle")
      .data( pointsdata )
   selection.enter().append("circle")
      .attr( "r", 9 )
      .call( drag )
      .on( "dblclick", function(d,i) {
          selected_point = i
          update()
      })
   selection
      .attr( "cx", function(d) { return scales.x( d.x ) } )
      .attr( "cy", function(d) { return scales.y( d.y ) } )
      .classed( "selected", function(d,i) { return i == selected_point } )
      .append("svg:title")
         .text( function(d) { return d.id } )


   // color bar:

   var color_bar_height = d3.select("#color_bar").attr("height")
   var line_color = window.getComputedStyle( 
       d3.select("#scatterpanel").selectAll("line:not(.selected)").node() )["stroke"]
   selection = d3.select("#color_bar").selectAll("rect")
      .data( distvalgrid.filter( function(x) { return mysigmoid(x) > alpha_threshold } ) )
   selection.enter().append("rect")
      .attr( "y", "0" )
      .attr( "width", color_bar_scale( distvalgridstep ) )
      .attr( "height", color_bar_height )
      .style( "fill", line_color )
   selection.exit()
      .style( { "fill-opacity": "0" } )
   selection
      .attr( "x", function(d) { return color_bar_scale( d ) } )
      .style( "fill-opacity", function(d) { return mysigmoid( d ) } )

   
   // Point info text

   if( selected_point > 0 ) 
       d3.select("#point_text").html( pointsdata[selected_point].text )
   else
       d3.select("#point_text").html( null )


   var rawstress = 0
   var confsqdistsum = 0
   for( i = 0; i < distslist.length; i++ ) {
      var confdist = Math.sqrt( square( pointsdata[ distslist[i].p2 ].x - pointsdata[ distslist[i].p1 ].x ) + 
         square( pointsdata[ distslist[i].p2 ].y - pointsdata[ distslist[i].p1 ].y ) )
      rawstress += square( confdist - distslist[i].dist )
      confsqdistsum += square( confdist ) 
   }

   d3.select("#bottomtextbox").text( ( rawstress / confsqdistsum ).toPrecision( 5 ) )
}


// Initial call to the update function:

update()

</script>
