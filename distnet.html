<!DOCTYPE html>
<meta charset="utf-8">

<title>Distance matrix graph display</title>

<style>

#scatterpanel circle {
   fill: DarkGray;
   stroke: black;
   fill-opacity: .9;
}

#scatterpanel line {
   stroke: DarkBlue; 
   stroke-width: 1.5; 
}

#scatterpanel circle.selected {
   stroke: DarkRed;
   stroke-width: 2;
}

#scatterpanel line.selected {
   stroke: DarkRed;
}

</style>



</svg>

<table style="padding-top:30px">
   <tr>
      <td><svg id="scatterpanel" class="chart" width="600" height="600"></svg></td>
      <td valign="top" align="left" style="padding-left:20px" width="200"><p id="point_text"></p></td>
    </tr><tr>
       <td><svg id="color_bar" width="600px" height="25px"></svg></td>
       <td></td>
    </tr><tr>
       <td style="padding-bottom:30px"><div id="slider_threshold" style="width:600px"></div></td>
       <td></td>
    </tr><tr>
       <td style="padding-bottom:20px"><div id="slider_slope" style="width:600px"></div></td>
       <td></td>
    </tr>
</table>


<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<link rel="stylesheet" href="https://rawgit.com/MasterMaps/d3-slider/master/d3.slider.css"></link>
<script src="https://rawgit.com/MasterMaps/d3-slider/master/d3.slider.js"></script>

<script>
// taken from http://stackoverflow.com/questions/4116992/how-to-include-json-data-in-javascript-synchronously-without-parsing
// only used here to load local data for testing
function loadTextFileAjaxSync( filePath )
{
  var xmlhttp = new XMLHttpRequest()
  xmlhttp.open( "GET", filePath, false )
  xmlhttp.send()
  return xmlhttp.responseText
}
</script>


<script>

// Prepare input data:

var inputdata = JSON.parse( loadTextFileAjaxSync( "points.json" ) )

function blowup( x ) { return Math.min( Math.max( 50 * ( x + 1 ), 0 ), 600 ) }

var pointsdata = []
for( i = 0; i < inputdata.conf.length; i++ ) 
   pointsdata.push( { 
      x: blowup( inputdata.conf[i][0] ), 
      y: blowup( inputdata.conf[i][1] ), 
      id: inputdata.ids[i],
      text: "Drug " + inputdata.ids[i] } )

var distslist = []
for( i = 0; i < inputdata.dm.length; i++ )
   for( j = i+1; j < inputdata.dm.length; j++ )
      distslist.push( { p1: i, p2: j, dist: inputdata.dm[i][j] })

</script>

<!--
Now we have two arrays:
  - pointsdata, with one element per data point, and for each data point the slots:
    - x and y (position on the panel, in pixels)
    - id: the ID to be used for the point's tool tip
    - text: the text to display in the 'point_text' element when the point is selected
  - distslist, with one element per line, and for each element the slots:
    - p1 and p2: The indexes of the two points in pointsdata that the line connects
    - dist: The feature-space distance of the two points

With this, we can go into the main script, which follows.
-->

<script>


// The minum alpha value, for which a line is still drawn
const alpha_threshold = .02

// The sigmoid function:
function sigmoid( x, threshold, slope ) {
   var midpoint = threshold + Math.log( 1/alpha_threshold - 1 ) / slope
   return 1 / ( 1 + Math.exp( -slope * ( x - midpoint ) ) )
}

// This function takes an object 'scales' with linear scales in slots 'x' and 'y',
// and changes them to get the desired x:y aspect ratio 'asp'.
function fix_aspect_ratio( scales, asp ) {
   var xfactor = ( scales.x.range()[1] - scales.x.range()[0] ) / 
      ( scales.x.domain()[1] - scales.x.domain()[0] )
   var yfactor = ( scales.y.range()[1] - scales.y.range()[0] ) / 
      ( scales.y.domain()[1] - scales.y.domain()[0] )
   var curasp = xfactor / yfactor  // current aspect ratio
   if( curasp > asp ) {  // x domain has to be expanded
      var cur_dom_length = ( scales.x.domain()[1] - scales.x.domain()[0] )
      var extension = cur_dom_length * ( curasp/asp - 1 ) / 2
      console.log( "extend x by", extension )
      scales.x.domain( [ scales.x.domain()[0] - extension, scales.x.domain()[1] + extension ] )      
   } else { // y domain has to be expanded
      var cur_dom_length = ( scales.y.domain()[1] - scales.y.domain()[0] )
      var extension = cur_dom_length * ( asp/curasp - 1 ) / 2
      console.log( "extend y by", extension )
      scales.y.domain( [ scales.y.domain()[0] - extension, scales.y.domain()[1] + extension ] )            
   }
   return( scales )
}

function minmax( x ) {
   return [ d3.min(x), d3.max(x) ]
}

// Set the scales
var scales = {
   x: d3.scale.linear()
      .domain( minmax( pointsdata.map( function(a) { return a.x } ) ) )
      .range( [ 0, 600 ] ),
   y: d3.scale.linear()
      .domain( minmax( pointsdata.map( function(a) { return a.y } ) ) )
      .range( [ 0, 600 ] ) }
fix_aspect_ratio( scales, 1 )      
scales.x.clamp( true )
scales.y.clamp( true )

// The two sliders:

var slider_threshold = d3.slider()
      .axis( true )
      .max( 2 )
      .value( .4 )
      .on( "slide", update )
d3.select('#slider_threshold').call( slider_threshold )

var slider_slope = d3.slider()
      .max( 50 )
      .value( 20 )
      .on( "slide", update )
d3.select('#slider_slope').call( slider_slope )      


// The scale object for the color bar:

var color_bar_scale = d3.scale.linear()
   .domain( [ slider_threshold.min(), slider_threshold.max() ] )
   .range( [ 0, 600 ])


// The data array for the color bar:

var distvalgrid = []
var distvalgridstep = ( color_bar_scale.domain()[1] - color_bar_scale.domain()[0] ) / 100 
for( v = color_bar_scale.domain()[0]; v < color_bar_scale.domain()[1]; v += distvalgridstep ) {
  distvalgrid.push( v )
}


// A drag behavior for the points, to be added below  to each point:

var drag = d3.behavior.drag()
   .on( "drag", function( d, i ) {
       d.x = scales.x.invert( scales.x(d.x) + d3.event.dx )
       d.y = scales.y.invert( scales.y(d.y) + d3.event.dy )
       update() })


// The currently selected (highlighted) point

var selected_point = -1


// The update function

function update() {


   // lines:

   mysigmoid = function( x ) { return sigmoid( x, slider_threshold.value(), -slider_slope.value() ) } 

   var shortdistslist = distslist.filter( 
      function(a) { return mysigmoid( a.dist ) > alpha_threshold } )

   var selection = d3.select("#scatterpanel").selectAll("line")
      .data( distslist )
   selection.enter().insert("line")
   selection
      .attr( "x1", function(d) { return scales.x( pointsdata[d.p1].x ) } )
      .attr( "y1", function(d) { return scales.y( pointsdata[d.p1].y ) } )
      .attr( "x2", function(d) { return scales.x( pointsdata[d.p2].x ) } )
      .attr( "y2", function(d) { return scales.y( pointsdata[d.p2].y ) } )
      .style( "display", function(d) { return mysigmoid( d.dist ) > alpha_threshold ? null : "none" } )
      .style( "stroke-opacity", function(d) { return mysigmoid( d.dist ) } )
      .classed( "selected", function(d,i) { return d.p1 == selected_point | d.p2 == selected_point } )


   // points:

   selection = d3.select("#scatterpanel").selectAll("circle")
      .data( pointsdata )
   selection.enter().append("circle")
      .attr( "r", 9 )
      .call( drag )
      .on( "dblclick", function(d,i) {
          selected_point = i
          update()
      })
   selection
      .attr( "cx", function(d) { return scales.x( d.x ) } )
      .attr( "cy", function(d) { return scales.y( d.y ) } )
      .classed( "selected", function(d,i) { return i == selected_point } )
      .append("svg:title")
         .text( function(d) { return d.id } )


   // color bar:

   var color_bar_height = d3.select("#color_bar").attr("height")
   var line_color = window.getComputedStyle( 
       d3.select("#scatterpanel").selectAll("line:not(.selected)").node() )["stroke"]
   selection = d3.select("#color_bar").selectAll("rect")
      .data( distvalgrid.filter( function(x) { return mysigmoid(x) > alpha_threshold } ) )
   selection.enter().append("rect")
      .attr( "y", "0" )
      .attr( "width", color_bar_scale( distvalgridstep ) )
      .attr( "height", color_bar_height )
      .style( "fill", line_color )
   selection.exit()
      .style( { "fill-opacity": "0" } )
   selection
      .attr( "x", function(d) { return color_bar_scale( d ) } )
      .style( "fill-opacity", function(d) { return mysigmoid( d ) } )

   
   // Point info text

   if( selected_point > 0 ) 
       d3.select("#point_text").text( pointsdata[selected_point].text )
   else
       d3.select("#point_text").text( null )
}


// Initial call to the update function:

update()

</script>