<!DOCTYPE html>
<meta charset="utf-8">

<title>distmat display</title>

<style>

#scatterpanel circle {
   fill: DarkGray;
   stroke: black;
   fill-opacity: .9;
}

#scatterpanel line {
   stroke: DarkBlue; 
   stroke-width: 1.5; 
}

#scatterpanel .selected_circle {
   stroke: DarkRed;
   stroke-width: 2;
}


</style>

<svg id="scatterpanel" class="chart" width="600" height="600">
</svg>


<table width="600px">
<tr><td><svg id="color_bar" width="600px" height="25px"></svg></td></tr>
<tr><td style="padding-bottom:30px"><div id="slider_threshold" style="width:600px"></div></td></tr>
<tr><td style="padding-bottom:20px"><div id="slider_slope" style="width:600px"></div></td></tr>
</table>

<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>

<link rel="stylesheet" href="https://rawgit.com/MasterMaps/d3-slider/master/d3.slider.css"></link>
<script src="https://rawgit.com/MasterMaps/d3-slider/master/d3.slider.js"></script>

<script>
// taken from http://stackoverflow.com/questions/4116992/how-to-include-json-data-in-javascript-synchronously-without-parsing
function loadTextFileAjaxSync( filePath )
{
  var xmlhttp = new XMLHttpRequest()
  xmlhttp.open( "GET", filePath, false )
  xmlhttp.send()
  return xmlhttp.responseText
}
</script>


<script>

// The minum alpha value, for which a line is still drawn
const alpha_threshold = .02

var inputdata = JSON.parse( loadTextFileAjaxSync( "points.json" ) )

function blowup( x ) { return Math.min( Math.max( 300 * ( x + 1 ), 0 ), 600 ) }

var pointspos = inputdata.conf.map( 
   function( a ) { return { x: blowup(a[0]), y: blowup(a[1]) } } )

function sigmoid( x, threshold, slope ) {
   var midpoint = threshold + Math.log( 1/alpha_threshold - 1 ) / slope
   return 1 / ( 1 + Math.exp( -slope * ( x - midpoint ) ) )
}


var slider_threshold = d3.slider()
      .axis( true )
      .max( 2 )
      .value( .4 )
      .on( "slide", update )
d3.select('#slider_threshold').call( slider_threshold )

var slider_slope = d3.slider()
      .max( 50 )
      .value( 20 )
      .on( "slide", update )
d3.select('#slider_slope').call( slider_slope )      


var distslist = []
for( i = 0; i < inputdata.dm.length; i++ )
   for( j = i+1; j < inputdata.dm.length; j++ )
      distslist.push( { p1: i, p2: j, dist: inputdata.dm[i][j] })

// color scale:
var color_bar_scale = d3.scale.linear()
   .domain( [ slider_threshold.min(), slider_threshold.max() ] )
   .range( [ 0, 600 ])

var distvalgrid = []
var distvalgridstep = ( color_bar_scale.domain()[1] - color_bar_scale.domain()[0] ) / 100 
for( v = color_bar_scale.domain()[0]; v < color_bar_scale.domain()[1]; v += distvalgridstep ) {
  distvalgrid.push( v )
}

// Add an invisible dummy line to 'scatterpanel', only to have something to read
// the style-defined stroke color from later, for use in the color var
var dummy_line = d3.select("#scatterpanel").append("line")
   .attr( "id", "dummy_line" )
   .attr( "style", "stroke-opacity:0")

var drag = d3.behavior.drag()
   .on( "drag", function( d, i ) {
       d.x += d3.event.dx
       d.y += d3.event.dy
       update() })


function update() {

   // lines:

   mysigmoid = function( x ) { return sigmoid( x, slider_threshold.value(), -slider_slope.value() ) } 

   var shortdistslist = distslist.filter( 
      function(a) { return mysigmoid( a.dist ) > alpha_threshold } )

   var selection = d3.select("#scatterpanel").selectAll("line")
      .data( distslist )
   selection.enter().insert("line")
   selection
      .attr( "x1", function(d) { return pointspos[d.p1].x } )
      .attr( "y1", function(d) { return pointspos[d.p1].y } )
      .attr( "x2", function(d) { return pointspos[d.p2].x } )
      .attr( "y2", function(d) { return pointspos[d.p2].y } )
      .style( "display", function(d) { return mysigmoid( d.dist ) > alpha_threshold ? null : "none" } )
      .style( "stroke-opacity", function(d) { return mysigmoid( d.dist ) } )
      .classed( "selected_line", function(d,i) { return d.p1==1 | d.p2==1 } )


   // points:

   selection = d3.select("#scatterpanel").selectAll("circle")
      .data( pointspos )
   selection.enter().append("circle")
      .attr( "r", 9 )
      .call( drag )
   selection
      .attr( "cx", function(d) { return d.x } )
      .attr( "cy", function(d) { return d.y } )
      .classed( "selected_circle", function(d,i) { return i==1 } )

   // color bar:

   var color_bar_height = d3.select("#color_bar").attr("height")
   var line_color = window.getComputedStyle( dummy_line.node() )["stroke"]
   selection = d3.select("#color_bar").selectAll("rect")
      .data( distvalgrid.filter( function(x) { return mysigmoid(x) > alpha_threshold } ) )
   selection.enter().append("rect")
      .attr( "y", "0" )
      .attr( "width", color_bar_scale( distvalgridstep ) )
      .attr( "height", color_bar_height )
      .style( "fill", line_color )
   selection.exit()
      .style( { "fill-opacity": "0" } )
   selection
      .attr( "x", function(d) { return color_bar_scale( d ) } )
      .style( "fill-opacity", function(d) { return mysigmoid( d ) } )
}

update()

</script>